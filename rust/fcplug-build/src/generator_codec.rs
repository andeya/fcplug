use std::fs;
use std::process::Command;
use std::sync::Arc;

use pilota_build::{
    CodegenBackend, Context, DefId, rir::Enum, rir::Message,
    rir::Method, rir::NewType, rir::Service,
};
use pilota_build::fmt::fmt_file;
use pilota_build::Output;
use pilota_build::plugin::{AutoDerivePlugin, PredicateResult};

use crate::{CODE_IO, deal_output, deal_result, new_shell_cmd};
use crate::config::IdlType;
use crate::generator::{GeneraterBackend, Generator};

impl Generator {
    pub(crate) fn _gen_code(self) {
        let pkg_dir = self.config.pkg_dir();
        let pkg_dir_str = pkg_dir.to_str().unwrap().to_string();
        let go_mod_name = self.config.go_mod_name();

        self.gen_go_codec_code();

        let import_gen_pkg = self.config.go_mod_path();
        let import_gen_pkg_var = format!("_ {}.ResultCode", go_mod_name);
        let rust_c_header_name_base = self.config.rust_c_header_name_base.clone();
        let rust_c_lib_dir = self
            .config
            .work_dir
            .as_os_str()
            .to_str()
            .unwrap()
            .to_string();

        *self.go_main_code.borrow_mut() = format!(
            r###"// Code generated by fcplug. DO NOT EDIT.

        package main

        /*
        #cgo CFLAGS: -I{rust_c_lib_dir}
        #cgo LDFLAGS: -L{rust_c_lib_dir} -l{rust_c_header_name_base}

        #include "{rust_c_header_name_base}.h"
        */
        import "C"
        import (
            "reflect"
            "unsafe"

            "{import_gen_pkg}"
            "github.com/andeya/gust"
        )

        // main function is never called by C to.
        func main() {{}}

        var (
            _ reflect.SliceHeader
            _ unsafe.Pointer
            _ gust.EnumResult[any, any]
            {import_gen_pkg_var}
        )

        "###
        );

        *self.go_pkg_code.borrow_mut() = format!(
            r###"// Code generated by fcplug. DO NOT EDIT.

            package {go_mod_name}
            /*
            #cgo CFLAGS: -I{rust_c_lib_dir}
            #cgo LDFLAGS: -L{rust_c_lib_dir} -l{rust_c_header_name_base}

            #include "{rust_c_header_name_base}.h"
            */
            import "C"

            import (
                "errors"
                "fmt"
                "reflect"
                "unsafe"

                "github.com/andeya/gust/valconv"
                "github.com/bytedance/sonic"
                "google.golang.org/protobuf/proto"
            )

            var (
                _ = errors.New
                _ = fmt.Sprintf
                _ reflect.SliceHeader
                _ unsafe.Pointer
                _ valconv.ReadonlyBytes
                _ = sonic.Marshal
                _ = proto.Marshal
            )

            "###
        );

        self.gen_rust_code();
        self.gen_rust_clib(r###"
typedef int8_t ResultCode;

typedef struct Buffer {
  uint8_t *ptr;
  uintptr_t len;
  uintptr_t cap;
} Buffer;

typedef struct RustFfiResult {
  ResultCode code;
  struct Buffer data;
} RustFfiResult;

typedef struct GoFfiResult {
  ResultCode code;
  uintptr_t data_ptr;
} GoFfiResult;

void free_buffer(struct Buffer buf);
uintptr_t leak_buffer(struct Buffer buf);

"###);

        deal_result(CODE_IO, fs::write(
            &self.config.go_lib_file(),
            self.go_pkg_code.borrow().as_str(),
        ));

        let go_mod_file = self.config.go_mod_file();
        if !go_mod_file.exists() {
            deal_result(CODE_IO, fs::write(
                &go_mod_file,
                format!(
                    r###"module {}

            go 1.18

            require (
                github.com/andeya/gust v1.5.2
                github.com/bytedance/sonic v1.9.2
                google.golang.org/protobuf v1.26.0
                github.com/apache/thrift v0.13.0
            )

            "###,
                    self.config.go_mod_path()
                ),
            ));
        } else {
            deal_output(Command::new(self.config.go_cmd_path("go"))
                .env("GO111MODULE", "on")
                .arg("get")
                .arg("github.com/andeya/gust@v1.5.2")
                .output());
            deal_output(Command::new(self.config.go_cmd_path("go"))
                .env("GO111MODULE", "on")
                .arg("get")
                .arg("github.com/bytedance/sonic@latest")
                .output());
            match self.config.idl_type() {
                IdlType::Proto | IdlType::ProtoNoCodec => deal_output(
                    Command::new(self.config.go_cmd_path("go"))
                        .env("GO111MODULE", "on")
                        .arg("get")
                        .arg("google.golang.org/protobuf@v1.26.0")
                        .output(),
                ),
                IdlType::Thrift | IdlType::ThriftNoCodec => deal_output(
                    Command::new(self.config.go_cmd_path("go"))
                        .env("GO111MODULE", "on")
                        .arg("get")
                        .arg("github.com/apache/thrift@v0.13.0")
                        .output(),
                ),
            }
        }

        if self.config.has_goffi {
            deal_result(CODE_IO, fs::write(
                self.config.go_main_file(),
                self.go_main_code.borrow().as_str(),
            ));
            if !self.config.go_main_impl_file().exists() {
                deal_result(CODE_IO, fs::write(
                    self.config.go_main_impl_file(),
                    format!(
                        r###"package main

            func init() {{
                // TODO: Replace with your own implementation, then re-execute `cargo build`
                GlobalGoFfi = _UnimplementedGoFfi{{}}
            }}

            "###
                    ),
                ));
            }
        }

        deal_output(Command::new(self.config.go_cmd_path("gofmt"))
            .arg("-l")
            .arg("-w")
            .arg(&pkg_dir_str)
            .output());

        deal_output(new_shell_cmd()
            .current_dir(&pkg_dir)
            .arg(self.config.go_cmd_path("go") + " mod tidy")
            .arg(&pkg_dir_str)
            .output());

        self.gen_go_clib();
    }
    fn gen_rust_code(&self) {
        let rust_mod_gen_file = self.config.rust_mod_gen_file();
        let rust_mod_impl_file = self.config.rust_mod_impl_file();
        match self.config.idl_type() {
            IdlType::Proto | IdlType::ProtoNoCodec => pilota_build::Builder::protobuf_with_backend(self.clone())
                .doc_header("// Code generated by fcplug. DO NOT EDIT.".to_string())
                .include_dirs(vec![self.config.include_dir()])
                .plugin(AutoDerivePlugin::new(
                    Arc::new(["#[derive(::serde::Serialize, ::serde::Deserialize)]".into()]),
                    |_| PredicateResult::GoOn,
                ))
                .ignore_unused(true)
                .compile([&self.config.corrected_idl_file], Output::File(rust_mod_gen_file.clone())),
            IdlType::Thrift | IdlType::ThriftNoCodec => pilota_build::Builder::thrift_with_backend(self.clone())
                .doc_header("// Code generated by fcplug. DO NOT EDIT.".to_string())
                .include_dirs(vec![self.config.include_dir()])
                .plugin(AutoDerivePlugin::new(
                    Arc::new(["#[derive(::serde::Serialize, ::serde::Deserialize)]".into()]),
                    |_| PredicateResult::GoOn,
                ))
                .ignore_unused(true)
                .compile([&self.config.corrected_idl_file], Output::File(rust_mod_gen_file.clone())),
        }

        let mut rust_code = fs::read_to_string(&rust_mod_gen_file).unwrap();
        if !self.config.has_rustffi {
            rust_code.push_str(&format!("pub(super) trait RustFfi {{}}"));
        }
        if !self.config.has_goffi {
            rust_code.push_str(&format!("pub(super) trait GoFfi {{}}"));
            rust_code.push_str(&format!("pub trait GoFfiCall {{}}"));
        }
        let rust_impl_name = self.config.rust_mod_impl_name();
        rust_code.push_str(&format!(
            r###"trait Ffi: RustFfi + GoFfi + GoFfiCall {{}}

        pub struct {rust_impl_name};

        impl GoFfiCall for {rust_impl_name} {{}}
        impl Ffi for {rust_impl_name} {{}}
        "###
        ));
        fs::write(&rust_mod_gen_file, rust_code).unwrap();
        fmt_file(rust_mod_gen_file);

        if !rust_mod_impl_file.exists() {
            let rust_impl_rustffi_code = self.rust_impl_rustffi_code.borrow();
            let rust_impl_goffi_code = self.rust_impl_goffi_code.borrow();
            let mod_gen_name = self.config.rust_mod_gen_name();
            deal_result(CODE_IO, fs::write(
                &rust_mod_impl_file,
                &format!(r###"#![allow(unused_variables)]

                pub use {mod_gen_name}::*;

                mod {mod_gen_name};

                {rust_impl_rustffi_code}

                {rust_impl_goffi_code}
                "###
                ),
            ));
            fmt_file(rust_mod_impl_file);
        }
    }
    fn gen_go_codec_code(&self) {
        match self.config.idl_type() {
            IdlType::Proto | IdlType::ProtoNoCodec => {
                deal_output(Command::new("protoc")
                    .arg(format!("--proto_path={}", self.config.work_dir.to_str().unwrap()))
                    .arg(format!("--go_out={}", self.config.pkg_dir().to_str().unwrap()))
                    .arg(self.config.corrected_idl_file.as_os_str())
                    .output());
            }
            IdlType::Thrift | IdlType::ThriftNoCodec => {
                deal_output(Command::new("thriftgo")
                    .arg(format!("-g=go"))
                    .arg(format!("-o={}", self.config.work_dir.join("gen-thrift").to_str().unwrap()))
                    .arg(self.config.corrected_idl_file.as_os_str())
                    .output());
                let go_mod_name = self.config.go_mod_name();
                deal_result(CODE_IO, fs::rename(
                    self.config.work_dir.join("gen-thrift").join(&go_mod_name).join(&format!("{go_mod_name}.go")),
                    self.config.pkg_dir().join(&format!("{go_mod_name}.thrift.go")),
                ));
            }
        };
    }
}

impl CodegenBackend for GeneraterBackend {
    fn cx(&self) -> &Context {
        self.context.0.as_ref()
    }
    fn codegen_struct_impl(&self, def_id: DefId, stream: &mut String, s: &Message) {
        match self.config.idl_type() {
            IdlType::Proto | IdlType::ProtoNoCodec => self.protobuf.codegen_struct_impl(def_id, stream, s),
            IdlType::Thrift | IdlType::ThriftNoCodec => self.thrift.codegen_struct_impl(def_id, stream, s),
        }
    }
    fn codegen_service_impl(&self, service_def_id: DefId, stream: &mut String, s: &Service) {
        let mut s = s.clone();
        s.methods = s
            .methods
            .iter()
            .map(|method| Arc::new(self.fix_empty_params(method)))
            .collect::<Vec<Arc<Method>>>();
        self.protobuf
            .codegen_service_impl(service_def_id, stream, &s);
        self.rust.codegen_service_impl(service_def_id, stream, &s);
        self.go.codegen(service_def_id, &s)
    }
    fn codegen_service_method(&self, service_def_id: DefId, method: &Method) -> String {
        let method = self.fix_empty_params(method);
        self.protobuf
            .codegen_service_method(service_def_id, &method);
        String::new()
    }
    fn codegen_enum_impl(&self, def_id: DefId, stream: &mut String, e: &Enum) {
        self.protobuf.codegen_enum_impl(def_id, stream, e);
    }
    fn codegen_newtype_impl(&self, def_id: DefId, stream: &mut String, t: &NewType) {
        self.protobuf.codegen_newtype_impl(def_id, stream, t);
    }
}
