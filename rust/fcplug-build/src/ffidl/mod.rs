use std::cell::RefCell;
use std::env::temp_dir;
use std::fs;
use std::process::Command;
use std::sync::Arc;

use pilota_build::fmt::fmt_file;
use pilota_build::Output;
use pilota_build::plugin::{AutoDerivePlugin, PredicateResult};

pub use config::{Config, GoObjectPath, UnitLikeStructPath};

use crate::{deal_output, exit_with_warning, new_shell_cmd};
use crate::ffidl::config::{CLibConfig, FfiSet, IdlType};
use crate::os_arch::get_go_os_arch_from_env;

mod gen_go;
mod gen_rust;
mod config;
mod make_backend;


#[derive(Debug, Clone)]
pub(crate) struct FFIDL {
    clib_config: CLibConfig,
    ffi_set: FfiSet,
    config: Arc<Config>,
    go_pkg_code: Arc<RefCell<String>>,
    go_main_code: Arc<RefCell<String>>,
    rust_impl_rustffi_code: Arc<RefCell<String>>,
    rust_impl_goffi_code: Arc<RefCell<String>>,
}

unsafe impl Send for FFIDL {}

impl FFIDL {
    pub(crate) fn generate(config: Config) {
        let _ = Self {
            clib_config: CLibConfig::new(&config),
            ffi_set: config.check_idl(),
            config: Arc::new(config),
            go_pkg_code: Arc::new(RefCell::new(String::new())),
            go_main_code: Arc::new(RefCell::new(String::new())),
            rust_impl_rustffi_code: Arc::new(RefCell::new("".to_string())),
            rust_impl_goffi_code: Arc::new(RefCell::new("".to_string())),
        }
            .rerun_if_changed()
            .gen_code()
            .inspect_err(|e| {
                exit_with_warning(255, format!("failed to generate code: {e:?}"))
            });
    }
    fn rerun_if_changed(self) -> Self {
        println!("cargo:rerun-if-changed={}", self.config.pkg_dir().to_str().unwrap(), );
        println!("cargo:rerun-if-changed={}", self.clib_config.clib_dir.to_str().unwrap());
        self
    }
    fn gen_code(self) -> anyhow::Result<()> {
        self.config.create_crate_dir_all();
        let pkg_dir = self.config.pkg_dir();
        let pkg_dir_str = pkg_dir.to_str().unwrap().to_string();
        let go_mod_name = self.config.go_mod_name();

        self.gen_go_codec_code()?;

        let import_gen_pkg = self.config.go_mod_path();
        let import_gen_pkg_var = format!("_ {}.ResultCode", go_mod_name);
        let rust_c_header_name_base = self.clib_config.rust_c_header_name_base.clone();
        let rust_c_lib_dir = self
            .clib_config
            .clib_dir
            .as_os_str()
            .to_str()
            .unwrap()
            .to_string();

        *self.go_main_code.borrow_mut() = format!(
            r###"// Code generated by fcplug. DO NOT EDIT.

        package main

        /*
        #cgo CFLAGS: -I{rust_c_lib_dir}
        #cgo LDFLAGS: -L{rust_c_lib_dir} -l{rust_c_header_name_base}

        #include "{rust_c_header_name_base}.h"
        */
        import "C"
        import (
            "reflect"
            "unsafe"

            "{import_gen_pkg}"
            "github.com/andeya/gust"
        )

        // main function is never called by C to.
        func main() {{}}

        var (
            _ reflect.SliceHeader
            _ unsafe.Pointer
            _ gust.EnumResult[any, any]
            {import_gen_pkg_var}
        )

        "###
        );

        *self.go_pkg_code.borrow_mut() = format!(
            r###"// Code generated by fcplug. DO NOT EDIT.

            package {go_mod_name}
            /*
            #cgo CFLAGS: -I{rust_c_lib_dir}
            #cgo LDFLAGS: -L{rust_c_lib_dir} -l{rust_c_header_name_base}

            #include "{rust_c_header_name_base}.h"
            */
            import "C"

            import (
                "errors"
                "fmt"
                "reflect"
                "unsafe"

                "github.com/andeya/gust/valconv"
                "github.com/bytedance/sonic"
                "google.golang.org/protobuf/proto"
            )

            var (
                _ = errors.New
                _ = fmt.Sprintf
                _ reflect.SliceHeader
                _ unsafe.Pointer
                _ valconv.ReadonlyBytes
                _ = sonic.Marshal
                _ = proto.Marshal
            )

            "###
        );

        self.gen_rust_code()?;
        self.gen_rust_clib();

        fs::write(
            &self.config.go_lib_file(),
            self.go_pkg_code.borrow().as_str(),
        )?;

        let go_mod_file = self.config.go_mod_file();
        if !go_mod_file.exists() {
            fs::write(
                &go_mod_file,
                format!(
                    r###"module {}

            go 1.18

            require (
                github.com/andeya/gust v1.5.2
                github.com/bytedance/sonic v1.9.2
                google.golang.org/protobuf v1.26.0
                github.com/apache/thrift v0.13.0
            )

            "###,
                    self.config.go_mod_path()
                ),
            )?;
        } else {
            deal_output(
                Command::new(self.config.go_cmd_path("go"))
                    .env("GO111MODULE", "on")
                    .arg("get")
                    .arg("github.com/andeya/gust@v1.5.2")
                    .output()?,
            );
            deal_output(
                Command::new(self.config.go_cmd_path("go"))
                    .env("GO111MODULE", "on")
                    .arg("get")
                    .arg("github.com/bytedance/sonic@latest")
                    .output()?,
            );
            match self.config.idl_type() {
                IdlType::Proto | IdlType::ProtoNoCodec => deal_output(
                    Command::new(self.config.go_cmd_path("go"))
                        .env("GO111MODULE", "on")
                        .arg("get")
                        .arg("google.golang.org/protobuf@v1.26.0")
                        .output()?,
                ),
                IdlType::Thrift | IdlType::ThriftNoCodec => deal_output(
                    Command::new(self.config.go_cmd_path("go"))
                        .env("GO111MODULE", "on")
                        .arg("get")
                        .arg("github.com/apache/thrift@v0.13.0")
                        .output()?,
                ),
            }
        }

        if self.ffi_set.has_goffi {
            fs::write(
                self.config.go_main_file(),
                self.go_main_code.borrow().as_str(),
            )?;
            if !self.config.go_main_impl_file().exists() {
                fs::write(
                    self.config.go_main_impl_file(),
                    format!(
                        r###"package main

            func init() {{
                // TODO: Replace with your own implementation, then re-execute `cargo build`
                GlobalGoFfi = _UnimplementedGoFfi{{}}
            }}

            "###
                    ),
                )?;
            }
        }

        deal_output(
            Command::new(self.config.go_cmd_path("gofmt"))
                .arg("-l")
                .arg("-w")
                .arg(&pkg_dir_str)
                .output()?,
        );

        deal_output(
            new_shell_cmd()
                .current_dir(&pkg_dir)
                .arg(self.config.go_cmd_path("go") + " mod tidy")
                .arg(&pkg_dir_str)
                .output()?,
        );

        self.gen_go_clib();
        Ok(())
    }
    fn gen_rust_code(&self) -> anyhow::Result<()> {
        let rust_mod_gen_file = self.config.rust_mod_gen_file();
        let rust_mod_impl_file = self.config.rust_mod_impl_file();
        match self.config.idl_type() {
            IdlType::Proto | IdlType::ProtoNoCodec => pilota_build::Builder::protobuf_with_backend(self.clone())
                .doc_header("// Code generated by fcplug. DO NOT EDIT.".to_string())
                .include_dirs(vec![self.config.include_dir()])
                .plugin(AutoDerivePlugin::new(
                    Arc::new(["#[derive(::serde::Serialize, ::serde::Deserialize)]".into()]),
                    |_| PredicateResult::GoOn,
                ))
                .ignore_unused(true)
                .compile([&self.config.idl_file], Output::File(rust_mod_gen_file.clone())),
            IdlType::Thrift | IdlType::ThriftNoCodec => pilota_build::Builder::thrift_with_backend(self.clone())
                .doc_header("// Code generated by fcplug. DO NOT EDIT.".to_string())
                .include_dirs(vec![self.config.include_dir()])
                .plugin(AutoDerivePlugin::new(
                    Arc::new(["#[derive(::serde::Serialize, ::serde::Deserialize)]".into()]),
                    |_| PredicateResult::GoOn,
                ))
                .ignore_unused(true)
                .compile([&self.config.idl_file], Output::File(rust_mod_gen_file.clone())),
        }

        let mut rust_code = fs::read_to_string(&rust_mod_gen_file).unwrap();
        if !self.ffi_set.has_rustffi {
            rust_code.push_str(&format!("pub(super) trait RustFfi {{}}"));
        }
        if !self.ffi_set.has_goffi {
            rust_code.push_str(&format!("pub(super) trait GoFfi {{}}"));
            rust_code.push_str(&format!("pub trait GoFfiCall {{}}"));
        }
        let rust_impl_name = self.config.rust_mod_impl_name();
        rust_code.push_str(&format!(
            r###"trait Ffi: RustFfi + GoFfi + GoFfiCall {{}}

        pub struct {rust_impl_name};

        impl GoFfiCall for {rust_impl_name} {{}}
        impl Ffi for {rust_impl_name} {{}}
        "###
        ));
        fs::write(&rust_mod_gen_file, rust_code).unwrap();
        fmt_file(rust_mod_gen_file);

        if !rust_mod_impl_file.exists() {
            let rust_impl_rustffi_code = self.rust_impl_rustffi_code.borrow();
            let rust_impl_goffi_code = self.rust_impl_goffi_code.borrow();
            let mod_gen_name = self.config.rust_mod_gen_name();

            fs::write(
                &rust_mod_impl_file,
                &format!(r###"#![allow(unused_variables)]

                pub use {mod_gen_name}::*;

                mod {mod_gen_name};

                {rust_impl_rustffi_code}

                {rust_impl_goffi_code}
                "###
                ),
            )
                .unwrap();
            fmt_file(rust_mod_impl_file);
        }
        Ok(())
    }

    fn gen_go_codec_code(&self) -> anyhow::Result<()> {
        let pkg_dir = self.config.pkg_dir();
        let pkg_dir_str = pkg_dir.to_str().unwrap().to_string();
        let go_mod_name = self.config.go_mod_name();
        let temp_dir = temp_dir();
        let temp_dir_str = temp_dir.to_str().unwrap().to_string();
        match self.config.idl_type() {
            IdlType::Proto | IdlType::ProtoNoCodec => {
                let temp_idl = temp_dir.join(go_mod_name.clone() + ".proto");
                let temp_idl_str = temp_idl.to_str().unwrap().to_string();
                fs::write(
                    &temp_idl_str,
                    fs::read_to_string(&self.config.idl_file).unwrap() + &format!("\noption go_package=\"./;{go_mod_name}\";\npackage {go_mod_name};\n"),
                ).unwrap();
                deal_output(
                    Command::new("protoc")
                        .arg(format!("--proto_path={temp_dir_str}"))
                        .arg(format!("--go_out={pkg_dir_str}"))
                        .arg(temp_idl_str)
                        .output()?,
                );
            }
            IdlType::Thrift | IdlType::ThriftNoCodec => {
                let temp_idl = temp_dir.join(go_mod_name.clone() + ".thrift");
                let temp_idl_str = temp_idl.to_str().unwrap().to_string();
                fs::copy(&self.config.idl_file, &temp_idl_str).unwrap();
                deal_output(
                    Command::new("thriftgo")
                        .arg(format!("-g=go"))
                        .arg(format!("-o={}", temp_dir.join("gen-thrift").to_str().unwrap()))
                        .arg(&temp_idl_str)
                        .output()?,
                );
                fs::copy(
                    temp_dir.join("gen-thrift").join(&go_mod_name).join(&format!("{go_mod_name}.go")),
                    pkg_dir.join(&format!("{go_mod_name}.thrift.go")),
                )
                    .unwrap();
            }
        };
        Ok(())
    }

    fn gen_rust_clib(&self) {
        let _ = cbindgen::Builder::new()
            .with_src(self.config.rust_mod_gen_file())
            .with_language(cbindgen::Language::C)
            .with_after_include(
                r###"
typedef int8_t ResultCode;

typedef struct Buffer {
  uint8_t *ptr;
  uintptr_t len;
  uintptr_t cap;
} Buffer;

typedef struct RustFfiResult {
  ResultCode code;
  struct Buffer data;
} RustFfiResult;

typedef struct GoFfiResult {
  ResultCode code;
  uintptr_t data_ptr;
} GoFfiResult;

void free_buffer(struct Buffer buf);
uintptr_t leak_buffer(struct Buffer buf);

"###,
            )
            .generate()
            .inspect(|b| {
                let _ = b.write_to_file(self.clib_config.rust_clib_h_path());
            })
            .inspect_err(|e| {
                exit_with_warning(254, format!("failed to generate rust clib: {e:?}"))
            });
    }

    fn gen_go_clib(&self) {
        if !self.ffi_set.has_goffi {
            return;
        }
        let clib_name = self.clib_config.go_clib_a_path();
        let clib_name_str = clib_name.file_name().unwrap().to_str().unwrap();
        if !self.clib_config.rust_clib_a_path().exists() {
            println!("cargo:warning='{}' file does not exist, should re-execute 'cargo build'", clib_name_str);
        } else {
            let mut cmd = new_shell_cmd();
            match get_go_os_arch_from_env() {
                Ok((os, arch)) => {
                    cmd
                        .env("GOOS", os.as_ref())
                        .env("GOARCH", arch.as_ref());
                }
                Err(e) => { println!("cargo:warning={e}") }
            }
            deal_output(
                cmd
                    .env("CGO_ENABLED", "1")
                    .env(
                        "GOROOT",
                        self.config.go_root_path.clone().unwrap_or_default(),
                    )
                    .arg(format!(
                        "{} build -buildmode=c-archive -o {} {}",
                        self.config.go_cmd_path("go"),
                        clib_name.to_str().unwrap(),
                        self.config.go_main_dir().to_str().unwrap(),
                    ))
                    .output()
                    .unwrap(),
            );
            if !clib_name.exists() {
                println!("cargo:warning=failed to execute 'go build -buildmode=c-archive', should re-execute 'cargo build' to ensure the correctness of '{}'", clib_name_str);
            }
            self.clib_config.rustc_link();
        }
        if self.clib_config.update_crate_modified() {
            println!("cargo:warning=The crate files has changed, it is recommended to re-execute 'cargo build' to ensure the correctness of '{}'", clib_name_str);
        }
    }
}
